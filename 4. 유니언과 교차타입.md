# 4. 유니언과 교차타입
## 4.1. 유니언타입과 교차타입의 사용사례
```ts
// 유니언타입
type SuccessResponse = {
    isSuccess: true
    data: {id: number}
}

type FetchingResponse = {
    isFetching: true
}

type QueryResponse = SuccessResponse | FetchingResponse 
```

```ts
// 교차타입
type ApiResponseBase = {
    code: number,
    message: string,
}

type ListApiResponse<T> = ApiResponseBase & {
    data: T[]
    pagination: {
        page: number
        limit: number
        hasNext: boolean
        totalCount: number
        totalPage: number
    }
}

type DataApiResponse<T> = ApiResponseBase & {
    data: T
}
```
## 4.2. 유니언 타입에서의 타입가드
```ts
// typeof를 사용한 타입가드
function typeGuardExample(a:number|string){
    if(typeof a === 'number') {
        return a.toLocaleString()
    }

    return a.toLowerCase()
}

// class와 instanceof를 사용한 타입가드
class ResponseError {
    code: number;
    message: string;
}

class JSSyntaxError {
    position: {
        line: number;
        col: number;
    };
    message: string
}

function printError(error: ResponseError | JSSyntaxError) {
    if(error instanceof ResponseError)  {
        console.log(error.code, error.message)
        return
    }
    console.log(error.position.line, error.position.col, error.message)
}

// in 키워드를 사용한 타입 가드 
type Car = {
    whill: number
    door: number
    window: number
    hasSunRoof: boolean
}

type Boat = {
    engine: string
    speed: number
    torque: number
    size: 'BIG' | 'SMALL'
}

function printVehicle(vehicle: Car|Boat){
    if('whill' in vehicle) {
        console.log(`나는 자동차를 갖고있어! 바퀴는 ${vehicle.whill}개야 내차의 문 개수는 ${vehicle.window}개`)
        return
    }

    console.log(`나는 보트를 갖고 있어! 내 보트의 엔진은 ${vehicle.engine}이고 최대 토트는 ${vehicle.torque}토크야!`)
}

// 공통된 키값을 갖고 그 키값의 차이로 타입가드
// Discriminating Unions
type SuccessResponse = {
    isSuccess: true,
    data: {id: number}
}

type FetchingResponse = {
    isSuccess: false,
    isFetching: true
}

type QueryResponse = SuccessResponse | FetchingResponse 

const test = (response:QueryResponse) => {
    console.log(response.data) // Error: Property 'data' does not exist on type 'QueryResponse'.
                               // Property 'data' does not exist on type 'FetchingResponse'.
    if(response.isSuccess) {
        console.log(response.data)
    }
}
```
## 4.3. 교차타입의 장점과 사용법
```ts
// 두 타입을 합쳐서 사용할 수 있다.
// 예를 들들어 어드민 화면에서 정보 조회하는 API의 params는 
// 검색필터와 데이터 목록의 페이지네이션 정보를 모두 필요로 하는데
// 검색 필터와 데이터의 페이지네이션 정보는 따로 관리를 해야 했고 
// 아래와 같이 사용했다.

type TablePagination = {
    limit: number,
    page: number,
}

type SearchFilter = {
    id: number,
    name: string,
    phoneNumber: string,
    nickname: string
}

type ApiResponseParams = TablePagination & Partial<SearchFilter>

// 테이블과 검색필터를 합쳐 Api 요청 파라미터를 만들었고 타입중복을 줄이고 요구사항이 변경돼서 검색필터가 늘어나더라도 SearchFilter만 수정해주면 따로 ApiResponseParmas를 수정하지 않아도 된다.
```